---
title: "Monolithic vs Micro service"
metaTitle: "Monolithic vs Micro service"
metaDescription: "Monolithic vs Micro service"
---

## 개요

### 정의

딱 맞는 정의라고 보기는 어렵지만 일반적으로 통용되는 내용으로 작성하여 보면
Monolith은 단일 어플리케이션에서 다양한 서비스를 제공하는 구조이고,
Micro Service는 service 또는 도메인 중심으로 어플리케이션을 나눈 구조라고 볼 수 있습니다.

### Micro service architecture의 대두

기존의 소규모 프로젝트에서는 Monolithic 구조로 진행을 하여도, 큰 문제는 없습니다.
하지만 점차 프로젝트 규모가 커지고, 이에 따른 요구사항이 커져감에 따라서 Monolithic 구조는 개발자에게 많은 피로감을 선사합니다.
크게 다음과 같은 문제점들이 있습니다.

1. 개발이 더디다 : IDE를 통한 빌드 시간, 코드를 고치고 실행에 걸리는 시간이 증가합니다.
2. 커밋 및 배포까지의 험난한 여정: 커밋 및 배포에 반영되는데에 있어서, 여러가지 내부 서비스들이 맞물리게 되면서 자연히 버그도 증가하고, 또한 배포 시기도 늦어지게 됩니다.
3. 확장의 어려움 : 실질적으로 하나의 코드에서 여러개의 서비스가 존재하지만 각각의 서비스들의 리소스 요건이 서로 맞지 않습니다. ( I/O intensive, CPU intensive jobs.... ), 이에 따라 낭비되는 리소스가 존재하거나 또는 리소스 조율에 신경을 써야합니다.
4. 확실하게 전달하기 어렵다. : 규모가 큰 프로젝트는 철저하게 테스트 하기도 어렵고, 결함 격리가 되지 않기 때문에 하나의 버그가 전체 프로젝트의 장애로 이루어질 수 있습니다.
5. 확장성의 어려움: 기존에 활용했던 기술스택을 변경하기 위해서는 전체 코드를 수정해야 합니다. 이는 규모가 커질수록 거의 불가능에 가까우며, 필요한 기술 스택을 적용하는데에 어려움을 만듭니다.

## [확장 큐브](https://microservices.io/articles/scalecube.html)

아래는 The art of scalability에서 가져온 scale cube에 관련된 내용입니다.

주 내용은 어플리케이션을 확장하는 방법에 있어서 크게 3가지 축으로 설명을 합니다.

1. 다중 인스턴스 ( X축 ) : 인스턴스를 여러개 두고, 앞단에 Load balancer를 통한 확장 구조입니다.
2. 파티셔닝 ( Z축 ) : 데이터를 파티셔닝 하거나 또는 사용자 id 별로 요청을 분산하는 형태입니다.
3. 어플리케이션을 서비스로 분해 ( Y축 ) : 하나의 어플리케이션에서 존재하는 여러개의 서비스를 분해하는 형태입니다. 각각의 서비스들은 또한 X축, Z축으로 확장 가능합니다.

![Scale Cube](./img/scaling-cube.jpg)
